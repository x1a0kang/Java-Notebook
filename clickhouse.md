* 为什么选clickhouse：
  * 储存的主体是日志，研究了日志方案，有很多大厂用clickhouse储存日志，腾讯,bilibili；
  * 大数据量：clickhouse可以容纳大数据量，集群架构支持动态扩缩容；
  * 写入性能高：clickhouse写入有很高的吞吐，几乎没有写入瓶颈（建议批量写入），日志的量每日平均4000W，市场好时可到8000W甚至上亿；
  * 查询性能：列式储存，数据分区，支持索引（索引巧妙），查询效率高；
  * 储存成本：列式储存，压缩率更高，且相比ES对内存要求低；
* clickhouse缺点：
  * 全文检索：clickhouse没有像ES那样的倒排索引，所以全文检索与ES有一定差距，但相比其他数据库已经是优秀的；
  * too many parts：clickhouse的merge速度跟不上写入速度。首先和分区键有关，其次，写入时也要分批写入，最后，还有一些配置可以优化merge速度的，比如background线程池大小；
  * 不支持更新，异步删除，需要更新和删除的需求无法使用；
  * zookeeper性能：实际只碰到了zk日志过大，没有遇到过因为zk导致的大量写入失败，因为峰值tps不是特别高。解决方式可以给clickhouse配置多个zk集群，在创建分布式表时可以指定zk集群，分散压力；
  * 学习成本较高：集群架构，分片副本和传统数据库有区别。建表分为本地表和全局表也是和传统数据库有区别。SQL基本一致，但聚合操作需要学习，尤其是分片集群在全局表上join，join次数可能造成指数级增长，导致数据库崩溃；
  * 吃CPU很高，因为多线程优化导致的，不太适合高并发查询；并且表聚合性能也不高；
  * 支持集群扩容，但集群数据平衡需要手动控制；

### clickhouse列式存储的特点

* 减少IO：当查询时，只需要读取相关列，且在磁盘上是顺序储存，可以大幅减少IO。
* 搞笑数据压缩：列内的数据格式相同，压缩比更大，节省磁盘空间；
* 高效利用CPU：列数据块可以更高效的利用CPU；
* 不适合单行操作，不适合点查

### 和clickhouse对比数据库：

* hive是关系型数据库，数据以文件的形式存在hdfs上，帮算法组处理过大模型训练数据，处理完后是以parquet文件写在hdfs上，查询较慢，用impala，适合离线数据处理；
* HBASE是列式数据库，有较高的读写性能，物理表存储在hdfs上，不支持SQL，需要借助Phoenix支持SQL和关联，无法高效处理多列过滤或聚合，只适合点查。HBASE数据结构冗余，有布隆过滤器等附加结构，会导致数据膨胀，存储成本较高；
* 整个Hadoop生态过于臃肿，维护和学习成本都比较高；
* vertica：相比clickhouse储存成本高，且商业版收费，扩容复杂，国内使用案例较少，冷数据无法自动分层；
* cassandra：查询功能受限，储存成本高（默认3副本），冷数据无法自动分层；
* Doris：在大规模数据时，查询性能不如clickhouse，存储成本高；
* impala，kylin：基于Hadoop生态；

* clickhouse储存结构：
  * 首先一张表会有partition字段，如果不设置分区，就是一个all分区，一般都要设置分区，否则clickhouse性能无法发挥；
  * 每个分区会有多个part，mergeTree会不断合并这些part；
  * 每个part中的文件：columns文件储存列信息，count计数文件，data数据文件，primary一级索引文件（每个颗粒第一行的主键），skp_index二级索引文件

* 一级索引（主键索引）：稀疏索引
  * 通过primary key指定，或通过order by指定，如果两个都指定，primary key必须是order by的前缀；
  * 数据在磁盘上，按主键列的字典升序顺序储存在磁盘上，是每一列内的数据按字典序升序排列的意思，不是列名按升序排列；
  * 数据被组织成颗粒，大小默认是8192行，可以在建表时修改；
  * 搜索时，先扫描颗粒，找到主键可能在的颗粒，这是第一阶段
  * 第二阶段数据读取，加载颗粒内所有行到clickhouse引擎中，查找实际匹配的行。实际数据储存时都是压缩后，多个颗粒可能在一个压缩块内，所以列mark文件内记录了block信息就是压缩块信息，还有颗粒信息就是解压后颗粒在什么位置；
  * 搜索非常依赖第一个主键列，如果where条件不能命中第一个主键列，扫描数量可能接近全表。在这种情况下，越靠前的主键列，基数越小，搜索的性能越好。
  * 分区列是日期，可以order第一列也是日期，配合过滤效果更好；
  * 二级索引：有minmax：记录每一块的最大最小值，set，布隆过滤器；

* clickhouse分区：
  * 默认每批次插入生成一个part，所以clickhouse鼓励分批写入，不要逐条写入；
  * 确保单次写入不要跨分区，否则会生成更多parts；
  * 分区粒度不要太细，否则会导致单次写入跨分区；
  * 要降低写入频率，增大写入批次的数量；
  * 后台合并线程池可以适当扩大；

* clickhouse副本间同步
  * 引擎要选择replicatedMergeTree；
  * 数据写入首先写入主副本，主副本把操作logEntry写入zookeeper的/log路径下
  * 其他副本监听zk的log目录，有新logEntry后，从主副本拉取数据，写入本地；
  * 建表语句也更特殊，需要指定分片和副本号，这些是在安装clickhouse时配置文件里配置的；
  * clickhouse的副本多数情况下是没有主副之分的，只有在执行某些异步操作时，如merge，alter才会临时选取一个主副本，但只是临时的。
* clickhouse扩缩容：
  * 扩容如果是增加分片，可以不需要重启已有节点，SYSTEM RELOAD CONFIG可以重新加载配置；
  * clickhouse没有数据balance机制，扩容或者缩容都要手动balance，可以把新分片的权重调高，到数据量和其他节点持平后，再降低权重；