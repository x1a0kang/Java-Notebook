# 网络

## 网络分层模型：osi七层，tcp/ip四层

* 应用层：提供应用之间的交互服务，定义了信息交换的格式。HTTP，SMTP，POP3，FTP，TELNET，SSH，DNS；
* 传输层：提供数据传输服务。TCP，UDP；
* 网络层：提供通信服务，选择合适的路由，使数据传输找到合适的主机。IP，ARP（IP解析到Mac地址），NAT（网络地址转换），ICMP（PING），路由器工作在网络层；
* 网络接口层：透明地传输比特流，交换机、网桥属于数据链路层，集线器中继器属于物理层；

## 网络为什么要分层

* 职责拆分，各层专一提供特定服务，相互之间不重叠，需要使用服务调用下一层接口即可，不关心其他层的内部实现；
* 提高整体灵活性，每一层都可以有多种实现方式，只要保持接口不变即可；
* 问题拆分，把大问题拆分成多个小问题，每个小问题有跟清晰的边界，容易设计，实现和标准化；

## 从输入URL到显示页面发生了什么

* 浏览器查询本地DNS缓存；
* 本地没有缓存时，请求DNS服务器获取IP地址；
* 与获取的IP建立TCP连接；
* 发送http请求报文；
* 获得服务器的响应，渲染页面；
* 可能请求页面中的资源，如图片等；
* 渲染完成，关闭TCP连接；

## DNS解析过程

* DNS有多级服务器：根服务器，顶级域服务器，权威服务器，本地服务器，每级服务器提供下一级服务器的IP地址。

1. 向本地DNS服务器发送请求，本地服务器检查本机缓存，如果没有，向根服务器发送请求；
2. 根服务器解析域名，返回对应的顶级域服务器，比如.cn，本地服务器去请求顶级服务器；
3. 顶级服务器解析，返回对应的权威服务器地址，本地服务器去请求权威服务器；
4. 权威服务器内有域名的备案，返回IP地址给本地服务器；
5. 本地服务器返回IP地址给主机；

* 通常本地DNS服务器缓存了很多的顶级域服务器，解析过程中会跳过根服务器，毕竟根服务器的数量太少。

## HTTPS的安全性

* **公钥加密，私钥解密；私钥签名，公钥解签**
* 使用SSL/TLS加密，**用非对称加密的方式生成对称加密要用的秘钥，后续的所有信息交换都用对称加密**；

* CA对服务器的公钥和其他信息计算hash后再用私钥加密，就是数字签名，签名和服务器信息一起就是CA颁发的数字证书；（**CA用私钥加密，其他人用公钥解密**）
* 客户端拿到服务器的证书后用CA的公钥解密数字签名，并计算哈希，验证哈希是否相等，是否是真的服务器，也拿到了服务器的公钥；
* 建立连接时，前两次通信客户端和服务端各生成一个随机数，明文发送，且确定加密算法，客服端发送第三个用服务器公钥加密后的随机数，然后客户端和服务端分别用这三个随机数生成对称加密的秘钥（会话秘钥）；（**C/S用公钥加密，私钥解密**）

## HTTP协议间的区别

* 1.0和1.1：
  * 1.0默认短连接，每次请求新建TCP连接，1.1默认长连接，可以连续发送多个请求，共用一个TCP连接，实际是基于TCP的短连接和长连接。
  * 1.1还新增了缓存控制，引入host头字段，解决了无法区分同一IP的不同虚拟主机；
  * 1.1还新增了range字段，支持断点续传等；

* 1.1和2.0：
  * 1.1是以文本格式传输，解析效率低，2.0通过**二进制分帧**将数据拆分为独立帧，每个帧标记流ID，解析更高效；
  * 1.1流水线请求可以连续发送多个请求，复用TCP连接，但是响应必须是串行处理，2.0通过**二进制分帧**将数据拆分为独立帧，每个帧标记流ID，实现单连接上多个请求/响应的并发传输；
  * 2.0还采用**HPACK算法**压缩头部，头部体积减少30%~90%，对请求小文件提升性能显著；

* 2.0和3.0：
  * 3.0基于QUIC协议，基于UDP的协议；
  * 2.0基于TCP，比如多路复用丢包，其他包都要等重发，3.0基于QUIC协议可以彻底规避TCP的阻塞问题；
  * 2.0需要TCP三次握手加TLS三次握手，3.0集成TLS1.3只需要TLS 1或0个RTT握手；
  * 3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而2.0 则需要依赖于 TCP 的错误恢复机制；

* 想要使用HTTP2.0，一定是HTTPS，可以在配置文件中指定enable，也可以使用NGINX反向代理指定协议，实际https证书大多配置在nginx内；
* spring boot默认HTTP1.1；
* nginx的负载均衡算法：轮询，加权轮询，IP哈希；

## 状态码

* 200：成功

* 300：重定向

* 400：客户端请求错误
  * 400：bad request：请求语法错误或参数无效

  * 403：forbidden，服务器拒绝，没有权限或IP被禁

  * 404：not found，资源不存在，路径错误

* 500：服务端错误
  * 500：internal server error，服务内错误

  * 502：bad gateway，网关错误，从上游（服务收到无效响应，就是挂了）

## TCP三次握手

* 客户端发送SYN(x)
* 服务端发送SYN(y)+ACK(x+1)；
* 客户端发送ACK(y+1)，第三次握手是可以携带数据的；
* 服务端收到syn但没有收到ack时，处于半连接状态，存放在半连接队列，DDOS攻击可以攻击这个队列；

## TCP四次挥手

* 客户端发送FIN(x)；
* 服务端发送ACK(x+1)，进入CLOSE_WAIT；
* 这中间服务端可能还有未发送完的数据，所以不能合并；
* 服务端发送FIN(y)；
* 客户端发送ACK(y+1)，进入TIME_WAIT，服务器端TIME_WAIT过多，说明是服务器端主动断开连接，可以设置服务器回收端口，也可以使用长连接减少TCP连接；
* 客户端还要等待2MSL，因为服务端可能没收到最后一个ACK，这时服务端会重新发送一个FIN，正好的两个MSL；

## TCP头包含哪些内容

* 源端口号和目标端口号；
* 序列号：占32位（4字节）；发送方给报文段分配一个序列号，接收方根据序列号来确认收到的数据，从而确认丢失的数据或者需要重传的数据。
* ACK：接收方收到数据后，它会发送一个确认应答（ACK = 1）给发送方，告诉发送方数据已成功接收；确认应答还包含期望接收的下一个字节的序列号，有助于发送方知道哪些数据已被接收，哪些数据需要重传。
* 检验和：占16位（2字节），检测数据在传输过程中是否发生错误。接收方会计算接收到的数据的校验和，并与发送方发送的校验和进行比较；不匹配，则接收方会丢弃该数据包，并可能要求发送方重传。
* 流量控制（窗口大小）：占16位（2字节），使用可变大小的滑动窗口协议来实现流量控制，防止发送方发送数据的速度过快而导致接收方无法处理。
* 数据偏移：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。
* 控制位：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。

## TCP和UDP的区别

* 面相连接：TCP建立连接需要三次握手，断开连接需要四次挥手；UDP是无连接的，直接发送数据；
* 可靠性：TCP提供确认，超时重传，数据校验等机制保证传输可靠性；UDP没有；
* 是否有状态：TCP在发送时会记录消息是否被发送，并且会等待接收方返回ack确认，同时启动计时器，如果收不到确认接收的消息，就会超时重发，是否被接收，维持连接状态表；而UDP不会，报文发出就不再关心状态；
* TCP通过滑动窗口进行流量控制，建立连接的接收方，会传递消息给发送方，可以接收的窗口大小，接收方防止溢出，UDP没有
* TCP面向字节流，数据分段发送，并且数据包带有序号，防止发送过程中产生乱序；UDP面向报文，数据整包发送；
* TCP主要应用于需要保证传输可靠性的场景，比如文件传输FTP，邮件POP3，SMTP，SSH，TELNET
* UDP主要应用于实时性要求高的场景，可以接收少量丢包，比如视频通话，直播，网络游戏

## TCP为什么可靠

1. 可靠连接：建立连接三次握手，断开连接四次挥手，保证了连接的可靠；
2. 序列号：每个数据包都有唯一的序列号，确保数据的顺序和完整性；
3. 校验和：可以检测数据包是否在传输过程中发生变化，有则抛弃这个数据包，发送方重传；
4. 超时重传：如果发送方发送的数据包超过了最大生存时间，发送方没有收到接收方的确认，发送方会重传数据包；
5. 流量控制：通过滑动窗口控制数据发送速率，防止数据阻塞
6. 拥塞控制：慢开始、拥塞避免、快重传、快恢复，避免网络拥塞造成数据阻塞或丢包；

## TCP流量控制

* 滑动窗口协议：允许接收方根据自己的处理能力，动态调整其可接收数据的窗口大小，并通过TCP报文的窗口字段将这一信息通知给发送方。发送方则根据接收到的窗口大小来调整其发送速率，确保在任何时刻，未确认的数据量不会超过接收窗口的大小。
* 接收方维护一个接收窗口，用于表示其当前可用的缓冲区大小。这个窗口大小会随着接收方处理数据的速度而变化。
* 发送方根据接收到的窗口大小来调整其发送速率。如果接收窗口的大小变为零，发送方将停止发送数据，直到接收到一个具有非零窗口大小的报文。
* 为了避免因接收窗口长时间为零而导致的死锁，发送方可能会发送零窗口探测报文（仅携带 1 字节的数据），以检查接收方是否已经有足够的缓冲区来接收新数据。

## TCP拥塞控制

* **慢开始、拥塞避免、快重传、快恢复。**TCP拥塞控制通过动态调整**拥塞窗口（cwnd）**的大小，平衡网络传输效率与稳定性，避免因数据过量注入导致网络拥塞。
* 慢启动：新建TCP连接时或发生超时重传时。每收到一个ACK确认，cwnd **指数级增长**。
* 拥塞避免：当cwnd超过**慢启动阈值（ssthresh）**时，进入拥塞避免阶段。cwnd **线性增长**，每轮RTT仅增加1 MSS。
* 快重传：发送方连续收到**3个重复ACK**，**立即重传丢失报文**，无需等待超时计时器（RTO）结束，减少延迟，与慢启动不同，此阶段不重置cwnd，而是进入快速恢复。
* 快恢复：快速重传后触发。将ssthresh降为当前cwnd的**1/2**，并执行拥塞避免算法；

## TCP什么时候重传

* 超时重传：发送数据后启动计时器，若RTO内未收到对应ACK，则判定数据丢失。发送方在**重传超时时间（RTO）**内未收到接收方的确认应答（ACK）时触发，RTO动态计算，基于往返时间和网络波动性，避免固定值导致性能问题。
* 快速重传：当发送方连续收到**3个重复ACK**时触发，无需等待超时。接收方收到乱序数据包时，会立即发送重复ACK（如期望序列号N，但收到N+1，则返回ACK=N）。发送方连续收到3个相同ACK时，推断数据包N丢失，立即重传。响应速度比超时重传快10倍以上，减少延迟。与**快速恢复算法**配合，避免拥塞窗口大幅缩小。
* 选择性重传：当接收方通过**SACK选项**明确反馈丢失数据块时触发。接收方检测到数据空洞（如已接收序列号1-100和200-300，但101-199缺失）。适用于**多数据包丢失**场景。
* 其他场景：比如校验和校验失败，接收方丢弃，请求方重传。

## TCP的粘包和拆包

* TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一**个完整的包可能会被 TCP 拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的 TCP 粘包和拆包问题。
* 解决方法：将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。

# 操作系统

## 进程线程协程

**进程（Process）**

- 定义：操作系统进行资源分配和调度的基本单位，每个进程拥有独立的虚拟地址空间、文件句柄等系统资源
- **资源分配**：进程间完全隔离，通过进程间通信（IPC）交互（如管道、共享内存）
- **切换**：需保存页表、内核栈等硬件上下文，涉及“用户态→内核态→用户态”切换

**线程（Thread）**

* **定义**：进程内的执行单元，CPU调度的最小单位，共享进程的内存和资源，但拥有独立的栈和寄存器

* **资源分配**：线程共享进程资源，通信通过共享内存和同步机制（如互斥锁）实现
* **切换**：仅保存内核栈和寄存器，涉及“用户态→内核态→用户态”切换
* **守护线程**是一种在后台运行的线程，其存在依赖于用户线程（非守护线程）。当所有用户线程执行结束时，JVM会直接退出，此时无论守护线程是否完成任务，都会被强制终止

**协程（Coroutine）**单线程内串行执行，需结合多线程/进程才能利用多核（如Go通过Goroutine与多线程结合）

* **定义**：用户态的轻量级线程，由程序显式调度，在单线程内实现协作式并发，共享线程资源
* **资源分配**：协程切换仅需保存寄存器等少量状态，无内核参与
* **切换**：仅保存寄存器，无内核参与
* 协程是多个协程分摊线程的时间片，使用的是同一个核，因此不适合CPU密集型的任务，更适合IO密集型的任务，且需要异步IO，如果线程阻塞了，多个协程也没有提升；

# 设计模式+排序

## 单例模式

* **私有构造方法**：确保外部代码不能通过构造器创建类的实例。
* **私有静态实例变量**：持有类的唯一实例。
* **公有静态方法**：提供全局访问点以获取实例，如果实例不存在，则在内部创建。

饿汉式

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

懒汉式（双重检查锁）：因为 `instance = new Singleton()` 并不是一个原子操作，可能会被重排序，导致其他线程获取到未初始化完成的实例。

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

静态内部类：当第一次加载 Singleton 类时并不会初始化 SingletonHolder，只有在第一次调用 getInstance 方法时才会导致 SingletonHolder 被加载，从而实例化 instance。

```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

## 稳定排序

* 冒泡：平均/最坏：O(n²)。相邻元素两两比较并交换，逐步将最大元素“冒泡”到末尾。
* 插入：平均/最坏：O(n²)。将未排序元素逐个插入已排序序列的正确位置，适合部分有序数据。
* 归并：最优/平均/最坏：O(n log n)。分治法，递归拆分数组后合并有序子序列。

## 不稳定排序

* 选择：最优/平均/最坏：O(n²)。每次选择未排序部分的最小元素，与当前位置交换。
* 快速：最优/平均：O(n log n)，最坏：O(n²)，数组已有序时。选取基准元素分区，递归排序左右子序列。
* 堆排：最优/平均/最坏：O(n log n)。构建最大堆，反复交换堆顶与末尾元素并调整堆结构。
