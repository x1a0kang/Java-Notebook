# Redis

## 基础

### Redis为什么快：

* Redis是基于内存的存储，内存速度比磁盘快很多；
* Redis的数据结构是经过优化的，性能很好；
* Redis单线程模型，没有线程切换和锁竞争的开销；
* Redis的IO多路复用模型效率高；

### Redis线程模型

**IO多路复用**

* 客户端与服务端对应一个socket，socket设为非阻塞模式；
* IO多路复用程序使用操作系统epoll进行监听这些socket。所以Redis的单线程不会阻塞在处理请求，而是一直在执行操作命令，监听连接的任务交给了内核；
* 当产生读写等操作命令时，epoll提供回调机制，将对应socket加入等待队列，Redis单线程不断处理这个队列中的事件；
* [【redis学习】Redis-IO多路复用 - 千本蛋 - 博客园](https://www.cnblogs.com/qianbendan/p/18184717)

### Redis多线程

* 从4.0版本起引入了多线程，但是用来清理脏数据，大键值对的删除操作；
* 6.0版本起引入了多线程，用于处理网络IO，事件的解析和执行依然是一个主线程；
* 已经就绪的事件在队列中，主线程轮询将事件分配给IO线程，阻塞等待IO线程读取socket，然后交给主线程执行；
* 主线程执行完毕后，把结果数据写入缓冲区，阻塞等待，再由IO线程写回socket，完成后主线程清空等待队列；
* [后端 - Redis 6.0 新特性：带你 100% 掌握多线程模型 - Redis - SegmentFault 思否](https://segmentfault.com/a/1190000040376111)

### 数据类型

* String：Redis特有的简单动态字符串SDS，除常规的储存外，可以用来计数，有+1的api INCR；还可以用作分布式锁，SETNX；在C语言字符串的基础上进行了优化
* Hash：字段少并且小的时候，用压缩列表实现，key和value顺序存储。字段多用字典实现，数组加链表的形式，但Redis做了很多优化；主要用于对象类型的储存；
* Set：字段少并且小的时候，用intset实现，使用在需要去重的场景，也可以做交集SINTER，并集SUNION，差集SDIFF；
* ZSet：有序集合，底层实现是压缩列表和跳表。zset在元素较多时使用**跳表加hash表**，通过member查询score是哈希表查的，时间复杂度是01；可以根据score排序。使用在需要排序的场景，比如排行榜，按时间排序等；
* List：Redis用C语言实现的双向链表，可以作为队列或栈LPUSH RPUSH LPOP RPOP；

### 底层数据类型

* SDS：保存了长度信息，获取长度的时间复杂度是O1，既可以保存文本数据，也可以保存二进制数据，因此可以储存图片；
  * 增加了长度记录，因此获取长度的时间复杂度是O1，而C语言中的字符串获取长度的时间复杂度是ON
  * 支持二进制，C语言是需要以\0来表示字符串结尾，而SDS可以通过长度计算，因此可以保存二进制数据，除文本外，也可以保存图片等；
  * 长度自动扩容，C语言可能缓冲区溢出，SDS可以在空间不够时扩容；
* 字典：用于HASH。数组加链表的形式，每个字典里有两个哈希表，每次只使用一个，扩容时从一个rehash到另一个，渐进式rehash；
* 压缩列表：list，zset和hash在元素较少时用的压缩列表，5.0引入，7.0已经用listpack取代ziplist；
* **跳表**：查找时，从最上层查找，如果当前层没有，往下层跳，直到找到。跳表插入时，层数是随机的。

### 跳表

* 跳表是一个多层的链表，每个节点包含member值，score值，向后和向下层的指针，最底层包含所有元素。
* 当多个节点score相同时，按成员对象的字典序排序。
* Redis通过**概率算法**动态生成新节点的层数，确保跳表结构的平衡性。
* 每次生成随机数时，节点层数增加的概率为25%。
* 最大层数为32（Redis 5.0+）或64（旧版本），防止极端情况下层级过高
* 新节点插入过程：例随机生成层数为3,。从最高层（假设原最高层为2）逐层下探，记录各层前驱节点；在第0-2层插入新节点，调整前驱节点的`forward`和`span`；因新层数3超过原最大层数2，将跳跃表的最大层高更新为3。

### RDB持久化

* 生成一份当前数据的快照，可以配置间隔时间，多久生成一次快照，save会阻塞所有请求，bgsave用异步处理持久化，不会阻塞请求。
* 如果Redis宕机，会丢失一定时间间隔的数据；
* 恢复数据速度快；

### AOF持久化

* 持续写入操作命令到缓冲区，定时刷入磁盘。可以配置间隔时间，有always，everysec（默认）和no三种。
* 当AOF文件过大时，Redis会异步重写一个新AOF文件，不会阻塞Redis处理请求；
* 重写期间，新的操作命令也会写入旧的AOF文件，因此重写期间偶有的命令都会写入磁盘两次，额外消耗磁盘IO；同时Redis也会维护一个缓冲区保存重写期间新增的命令，因此重写时也会额外消耗内存。
* AOF相比RDB更实时，最多只会丢失一秒的数据；
* AOF相比RDB文件更大，储存的是命令，因此恢复数据的速度也更慢；

### 混合持久化：

* Redis4.0之后提供的方式；
* 开启后当AOF文件重写时，会生成一个RDB文件，然后再增量写入AOF命令；
* 恢复数据时，当AOF开启时，如果目录下存在RDB文件，会先加载RDB文件，然后再加载AOF文件，这样既快速，又实时；



### 过期数据怎么删除

* Redis内对设有过期时间的key维护了一个字典，key指向库中的某个key，value保存的是这个key的过期时间；
* 惰性删除：只有当过期key被查询时才会检查是否过期，可能会造成大量key堆积；
* 定期删除：定期从字典抽取一部分key检查过期时间，并不保证所有过期key都会删除；
* 定时删除：每个key都设置一个定时器，所有key在到达过期时间时就删除，但对CPU的压力最大；
* 延时队列：所有key放在一个延迟队列里，到期后删除；
* Redis默认采用定期+惰性删除；

### 内存淘汰策略

当内存达到配置的最大内存时触发，64位操作系统下，不设置最大内存

* 过期LRU
* 所有LRU
* 过期RANDOM
* 所有RANDOM
* 过期LFU
* 所有LFU
* 不过期，报错

### Redis事务

* 运行错误时，只有那条命令不会执行，其他命令都会执行，不支持回滚，因此Redis事务不支持原子性；
* 使用lua脚本可以保证隔离性，错误命令之后不会执行，但之前的命令不会回滚，所以还是不支持原子性；

### 缓存击穿

缓存中的数据过期，大量请求直接到达数据库。解决方法：

* 热点数据定时延长过期时间，
* 从数据库请求数据的方法加锁，使同时只有一个请求达到数据库

* 缓存穿透：指缓存中没有数据，数据库中也没有的数据，导致每次请求都会到达数据库。解决方法：
  * 请求校验，过滤无效请求；
  * 缓存空数据；
  * 布隆过滤器，储存所有存在的数据，先验证数据是否存在；

### 缓存雪崩

大量的缓存同时过期或Redis宕机导致大量请求直接到达数据库，解决方法：

* 热点数据预加载；
* 过期时间增加随机值，防止同时过期；
* Redis集群部署；

### Redis集群

* 主从复制：主节点写，从节点读，从节点从主节点同步数据，延迟可能导致数据差异，且从节点无法替主节点分担写的压力，由于网络分区或节点故障时，可能导致多个主节点的情况（脑裂）；当主节点挂了时，要手动选择一个从节点成为主节点，修改配置；
* 哨兵：主要用来监控 Redis 主从架构中的实例，并在主节点出现故障时，自动进行故障转移，**监控、选主、通知**。多个哨兵监控主从节点，当一个哨兵发现某个节点ping不通时，就会标记为主观下线，当多个哨兵都把这个节点标记时，就会客观下线这个节点，如果这个节点是主节点，哨兵就会选举一个新的主节点；
  1. 故障节点主观下线：当一个哨兵发现某个节点ping不通时，就会标记为主观下线；
  2. 故障节点客观下线：当多个哨兵都把这个节点标记下线时，就会客观下线这个节点。如果下线的节点是从节点或哨兵节点，不会进行后续的操作。如果是下线的节点是主节点，则会开始进行故障转移；
  3. 哨兵集群选举Leader，类似Raft的选举算法；
  4. 哨兵leader选择主节点：1. 不选择故障的节点；2. 选择优先级最大的节点，没有则跳过；选择复制偏移量最大的节点，没有则跳过；选择runid最小的节点；
  5. 通知其他从节点新主节点，并进行同步；
* 集群模式：至少需要3个master和3个slave保证高可用，通过哈希槽（16384个）分配数据。集群模式自带哨兵模式，每个节点都会互相探测（gossip协议）。
  * 节点取余：优点简单，缺点是扩缩容时，几乎所有数据都要重新分配；
  * 一致性哈希：将哈希值空间组织成一个环，数据项和节点都映射到这个环上。数据项由其哈希值直接映射到环上，然后顺时针分配到遇到的第一个节点。优点：减少了迁移时数据移动的量。缺点：数据可能分布不均，且故障转移时，前面节点的数据都会转移到后一个节点上，对后一个节点造成压力；
  * 虚拟槽分区：先把数据分配到虚拟槽中，集群中的每个节点负责一定数量的槽。优点是分布更均匀，移动数据时可以灵活地把槽数据从一个节点移动到另一个节点；

### 集群的伸缩

* 当需要扩容时，新的节点被添加到集群中，集群会自动执行数据迁移，以重新分布哈希槽到新的节点。
* 数据迁移的过程可以确保在扩容期间数据的正常访问和插入。
* 当数据正在迁移时，客户端请求可能被路由到原有节点或新节点。Redis Cluster 会根据哈希槽的映射关系判断请求应该被路由到哪个节点，并在必要时进行重定向。
* 如果请求被路由到正在迁移数据的哈希槽，Redis Cluster 会返回一个 MOVED 响应，指示客户端重新路由请求到正确的目标节点。这种机制也就保证了数据迁移过程中的最终一致性。
* 当需要缩容时，Redis 集群会将槽从要缩容的节点上迁移到其他节点上，然后将要缩容的节点从集群中移除。

### 集群数据同步

* 全量同步
  * 从节点首次加入集群，或主从断开连接时间过长；
  * 从节点发送`SYNC`命令请求同步，主节点判断需全量同步
  * 主节点执行`BGSAVE`生成RDB快照文件，同时将后续写命令缓存至`replication buffer`；
  * 主节点将RDB文件传输给从节点，从节点清空旧数据并加载RDB文件
  * 主节点将`replication buffer`中的增量写命令发送给从节点，确保数据一致性
  * 同步完成后，主从建立长连接，主节点持续推送新写命令
* 增量同步
  * 主节点维护**复制积压缓冲区（`repl_backlog_buffer`）**，是一个环形缓冲区，保存最近的命令
  * 从节点发送`PSYNC <runid> <offset>`同步请求，携带主节点ID和复制偏移量
  * 主节点校验`runid`和`offset`，若偏移量在缓冲区范围内，则发送增量命令
  * 从节点执行增量命令，保持与主节点数据一致

---

## 应用

### Redis用作分布式锁（Redisson优势）

* 基本原理是使用SETNX，解锁直接删除key。但这样当获取锁的服务宕机时，锁无法释放，导致后续无法再有服务获取到锁；
* 为了避免上述问题，需要给锁设置一个过期时间，并且获取锁和设置过期时间必须是原子操作，否则还是可能有上述问题；并且锁的时间过短，可能导致锁提前释放，时间过长会影响性能（如果服务挂了，要等过期时间才能解锁）；
* 实现锁的自动续期，当加锁的操作没有完成时，自动给锁续期，使用Redisson，默认当使用Redisson加锁时，如果没有设置过期时间（leaseTime），则会触发Redisson的看门狗机制，会启动一个后台守护线程，守护线程通过定时任务定时对锁进行续期，expire，自动续期时间是超时时间的三分之一。
* 看门狗基于Netty的**时间轮算法**（HashedWheelTimer）实现高效定时任务调度。每个锁对应一个后台守护线程，周期性执行续期操作，不影响主线程业务执行。
* 续期操作通过Lua脚本实现原子性，确保以下逻辑：检查锁是否仍由当前线程持有（通过线程ID验证）；若持有，则重置锁过期时间为初始值（如30秒）；返回续期结果，失败时停止后续任务；
* 在获取锁成功之后，就会调用 scheduleExpirationRenewal(threadId) 方法开启自动续约，具体是由在 map 中添加业务名称和任务定时器，这个定时器会在一定时间内执行，比如说 10 秒就会自动开启任务，而该定时器中的任务就是不断的重置锁的最大超时时间
* redisson还做到了锁可重入，内部用的是hashmap，不是string，map内的field为每个服务特有的值，客户端uuid+线程id，如果服务获取了锁，验证这个field是不是自己的唯一值，如果是，就可以重入，value值加一，为零时释放锁，并且重置过期时间；
* 具体使用：配置类定义redissonClient，getLock(key)，lock，unlock
* red lock：因为Redis的主从同步是异步的，可能导致某一个线程获取了锁，但是主节点故障，从节点在还没有同步到数据的情况下被选为主节点，这时另一个线程来获取锁，还是可以获取到的，这就会产生并发问题。red lock的解决方式就是，在集群中的多个节点上获取锁（建议5个），超过一半的节点获取到锁（3个），才算是获取成功；
* ==集群中的分布式锁==

### 其他的分布式锁

* zookeeper：通过创建临时顺序节点，节点最小者获得锁，监听前序节点释放事件。强一致性（基于 ZAB 协议），天然支持锁续期和公平性。性能低，依赖磁盘同步，实现复杂，需要非公平锁，重入，自动过期续期都要客户端自行处理；
* 数据库：利用唯一索引或 `SELECT ... FOR UPDATE` 行锁，性能低，无自动过期；

* Redis乐观锁：使用watch监控键的变化，如果有变化放弃执行任务。

### Redis用作限流

* ==具体使用方式==，redissonClient.getRRateLimiter
* 滑动窗口算法：把时间窗口分为多个小的窗口，统计最近时间段内的请求量。

  * 在Redis中可以使用zset实现，score为请求的时间戳，每次请求删除超出时间窗口的旧数据，统计当前窗口下的数量，并刷新缓存时间；为保证原子性，用lua脚本实现；
  * 解决固定窗口的边界突破限制问题，限流更精确，限流更平滑。
  * 缺点是无法应对突发流量，还要记时间戳，占用内存较多。

* redisson：令牌桶算法，以固定速率向桶中添加令牌，每次请求需要从桶里获取令牌，如果获取失败等待或拒绝；
  * **支持突发流量**，短时间内大量请求可以消耗堆积的令牌，支持突发流量是一个双刃剑，不能让令牌数量超过实际的项目极限；
  * 速率可控，可以调整令牌的生成速率

  * 其他算法：固定窗口算法，实现简单，但无法应对突发流量，集中流量也可能造成1秒内后半段不可用，也可能造成两倍流量
  * 其他算法：漏桶法，请求进入桶内，系统稳定速度处理桶内的请求，但无法应对突发流量，消息队列
  * RRateLimiter，通过trySetRate设置令牌的生成速率，和时间窗口，如trySetRate(Type.OVERRALL,10,1,SECONDS)，表示1秒生成十个令牌。tryAcquire()获取令牌；rate就是桶的容量，如果想10个每秒生成，但桶的容量为20的话，就要设置20,2,SECONDS;
  * RRateLimiter底层使用hash结构储存令牌桶的参数rate，interval，type；有个String保存令牌数，incr原子操作；有个zset保存获取令牌的时间戳，令牌可能过期，要回收，并通过lua脚本保证原子性，hsetnx；
  * RRateLimiter生成令牌是在获取时计算离上次生成的时间，生成这段时间应该生成数量的令牌，再看请求的令牌数是不是小于当前令牌数；不使用定时任务补充，避免资源开销，减少无效计算，如桶已满，不用持续生成令牌；

* 其他限流组件：guava，Resilience4j只能单机限流，sentinel可以分布式，也可以熔断降级，没时间引入；

### Redis用作统计UV

* 用户量比较小的时候，可以用set处理，但是如果用户量十万百万量级，维护一个set对性能消耗很大；
* 用户量大时，用hyperLogLog，计算结果不是一个精确值，有一定误差。
* 除了Redis可以用clickhouse，做id单列的distinct速度非常快；

### Redis内大key处理

* 字符串按长度分块，保存多个key；
* zset按score拆分；
* hash分桶储存，可以通过字段hash值区分；
* 如果储存的是字符串，可以通过压缩算法压缩后储存；